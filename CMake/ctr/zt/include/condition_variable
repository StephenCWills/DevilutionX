#pragma once

#include_next <condition_variable>

#include <3ds/synchronization.h>

namespace std {
    
enum class cv_status {
    no_timeout,
    timeout  
};
    
class condition_variable {
public:
    condition_variable();
    condition_variable(const condition_variable&) = delete;
    
    void notify_one() noexcept;
    void notify_all() noexcept;
    void wait(unique_lock<mutex>& lock);
    
    template<class Predicate>
    void wait(unique_lock<mutex>& lock, Predicate pred);
    
    template<class Rep, class Period>
    cv_status wait_for(unique_lock<mutex>& lock, const chrono::duration<Rep, Period>& rel_time);
    
    template<class Rep, class Period, class Predicate>
    bool wait_for(unique_lock<mutex>& lock, const chrono::duration<Rep, Period>& rel_time, Predicate pred);
    
    template<class Clock, class Duration>
    cv_status wait_until(unique_lock<mutex>& lock, const chrono::time_point<Clock, Duration>& timeout_time);
    
    template<class Clock, class Duration, class Pred>
    bool wait_until(unique_lock<mutex>& lock, const chrono::time_point<Clock, Duration>& timeout_time, Pred pred);
    
    CondVar *native_handle();
    
private:
    CondVar cond_var;
};

condition_variable::condition_variable()
{
    CondVar_Init(&cond_var);
}

void condition_variable::notify_one() noexcept
{
    CondVar_Signal(&cond_var);
}

void condition_variable::notify_all() noexcept
{
    CondVar_Broadcast(&cond_var);
}

void condition_variable::wait(unique_lock<mutex>& lock)
{
    mutex *mutex = lock.mutex();
    LightLock *lightLock = nullptr;
    if (mutex != nullptr)
        lightLock = mutex->native_handle();
    CondVar_Wait(&cond_var, lightLock);
}

template<class Predicate>
void condition_variable::wait(unique_lock<mutex>& lock, Predicate pred)
{
    while (!pred())
        wait(lock);
}

template<class Rep, class Period>
cv_status condition_variable::wait_for(unique_lock<mutex>& lock, const chrono::duration<Rep, Period>& rel_time)
{
    mutex *mutex = lock.mutex();
    LightLock *lightLock = nullptr;
    if (mutex != nullptr)
        lightLock = mutex->native_handle();
    
    auto rel_time_ns = chrono::duration_cast<chrono::nanoseconds>(rel_time);
    s64 timeout_ns = rel_time_ns.count();
    
    if (CondVar_WaitTimeout(&cond_var, lightLock, timeout_ns) != 0)
        return cv_status::timeout;
    return cv_status::no_timeout;
}
    
template<class Rep, class Period, class Predicate>
bool condition_variable::wait_for(unique_lock<mutex>& lock, const chrono::duration<Rep, Period>& rel_time, Predicate pred)
{
    return wait_until(lock, chrono::steady_clock::now() + rel_time, move(pred));
}

template<class Clock, class Duration>
cv_status condition_variable::wait_until(unique_lock<mutex>& lock, const chrono::time_point<Clock, Duration>& timeout_time)
{
    auto now = chrono::system_clock::now();
    if (timeout_time <= now)
        return cv_status::timeout;
    auto rel_time = timeout_time - now;
    return wait_for(lock, rel_time);
}
    
template<class Clock, class Duration, class Pred>
bool condition_variable::wait_until(unique_lock<mutex>& lock, const chrono::time_point<Clock, Duration>& timeout_time, Pred pred)
{
    while (!pred()) {
        if (wait_until(lock, timeout_time) == cv_status::timeout)
            return pred();
    }
    return true;
}

LightLock *condition_variable::native_handle()
{
    return &cond_var;
}

} // namespace std